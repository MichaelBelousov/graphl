<!doctype html>
<html lang="en" style="height: 100%;">
  <head>
    <meta charset="utf-8" />

    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Graphl Editor</title>
    <!-- FIXME: remove temp -->
    <script src="https://cdn.jsdelivr.net/npm/@tsparticles/confetti@3.0.3/tsparticles.confetti.bundle.min.js"></script>
  </head>

  <body style="height: 100%; margin: 0; padding: 0;" >
    <style>
        body {
          overflow-x: hidden;
          display: grid;
          grid-template-columns: 0px 100vw 50vw;
          margin: 0;
          padding: 0;
        }
        #dvui-canvas {
          height: 100vh;
          display: block;
          outline: none;
          caret-color: transparent;
        }
        #react-app {
          height: 100vh;
        }
    </style>
    <!-- need tabIndex for the canvas to receive keydown/keyup/beforeinput events -->
    <canvas id="dvui-canvas" tabIndex="1"></canvas>
    <div id="react-app"></div>
    <script type="module" src="./demo.tsx"></script>
    <script type="module">
      import * as graphl from "./WebBackend.js";

      const showText = "0px 50vw 50vw";
      const noShowText = "0px 100vw 50vw";

      const sexpToSql = (sexp) => {
        if (Array.isArray(sexp)) {
          let sql = "";

          const [func, ...params] = sexp;

          const handlePrev = (ignore = false) => {
            if (!Array.isArray(params[0]))
              return;
            const execParam = params.shift();
            if (!ignore) {
              const prev = sexpToSql(execParam);
              sql += prev;
              sql += '\n';
            }
          };

          if (func.symbol === "SELECT") {
            handlePrev();
            params.forEach(p => { if (typeof p !== "string") throw Error("bad SELECT arg"); })
            sql += sexpToSql(func) + ' ' + params.join(',');

          } else if (func.symbol === "WHERE") {
            handlePrev();
            sql += sexpToSql(func) + ' ' + params.map(sexpToSql).join(',');

          } else if (func.symbol === "FROM") {
            handlePrev();
            params.forEach(p => { if (typeof p !== "string") throw Error("bad FROM arg"); })
            sql += sexpToSql(func) + ' ' + params.join(',');

            // assume it's a binary operator
          } else {
            handlePrev();
            sql += `${sexpToSql(params[0])} ${sexpToSql(func)} ${sexpToSql(params[1])}`;

          }

          return sql;

        } else if (typeof sexp === "object" && "symbol" in sexp) {
          return sexp.symbol;

        } else if (typeof sexp === "string") {
          return `'${sexp}'`

        } else if (typeof sexp === "number") {
          return `${sexp}`

        } else {
          throw Error("unexpected value:", sexp);
        }
      };

      let ide;

      async function main() {
        ide = new Promise((resolve, reject) => {
          document.body.onload = () => {
            const canvas = document.getElementById("dvui-canvas");
            const result = new graphl.Ide(canvas, {
              userFuncs: {
                "Confetti": {
                  inputs: [{ name: "particle count", type: "i32" }],
                  outputs: [],
                  impl(particleCount) {
                    confetti({
                      particleCount,
                      spread: 70,
                      origin: { y: 0.6 },
                    });
                  }
                },
                "ECSQL-exec": {
                  inputs: [{ name: "query", type: "code" }],
                  outputs: [{ name: "string", type: "string" }],
                  impl(code) {
                    console.log('QUERY:', sexpToSql(code));
                  }
                },
                "testme": {
                  inputs: [{ name: "query", type: "string" }],
                  outputs: [],
                  impl(str) {
                    console.log(str);
                  }
                },
                // dummy nodes
                "SELECT": {
                  inputs: [{ name: "column", type: "string" }],
                  outputs: [],
                },
                "WHERE": {
                  inputs: [{ name: "condition", type: "bool" }],
                  outputs: [],
                },
                "FROM": {
                  inputs: [{ name: "table", type: "string" }],
                  outputs: [],
                },
              },
              graphs: {
                "main": {
                  nodes: [
                    {
                      id: 1,
                      type: "Confetti",
                      inputs: {
                        0: { node: 0, outPin: 0 },
                        1: { int: 100 },
                      }
                    },
                    {
                      id: 2,
                      type: "return",
                      inputs: {
                        0: { node: 1, outPin: 0 },
                      }
                    },
                  ]
                }
              },
              /*
              preferences: {
                graph: {
                  scale: 0.7,
                  origin: { x: 0, y: 0 },
                },
              },
              */
            });
            resolve(result);
          };

          document.body.onerror = (err) => reject(err);
        });

        document.addEventListener("keydown", (e) => {
          const isCtrlShiftE = e.ctrlKey && e.shiftKey && /[eE]/.test(e.key);
          if (!isCtrlShiftE) return;
          e.preventDefault();
          document.body.style["grid-template-columns"]
            = document.body.style["grid-template-columns"] === showText
            ? noShowText
            : showText;
        });
      }

      void main();
    </script>
  </body>
</html>
