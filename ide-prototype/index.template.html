<!doctype html>
<html lang="en" style="height: 100%;">
  <head>
    <meta charset="utf-8" />

    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Grappl Editor</title>
    <!-- FIXME: remove temp -->
    <script src="https://cdn.jsdelivr.net/npm/@tsparticles/confetti@3.0.3/tsparticles.confetti.bundle.min.js"></script>
  </head>

  <body style="height: 100%; margin: 0; padding: 0;" >
    <style>
        body {
          overflow-x: hidden;
          display: grid;
          grid-template-columns: 0px 100vw 50vw;
          margin: 0;
          padding: 0;
        }
        #dvui-canvas {
          height: 100vh;
          display: block;
          outline: none;
          caret-color: transparent;
        }
        #react-app {
          height: 100vh;
        }
    </style>
    <!-- need tabIndex for the canvas to receive keydown/keyup/beforeinput events -->
    <canvas id="dvui-canvas" tabIndex="1"></canvas>
    <div id="react-app"></div>
    <script type="module" src="./demo.tsx"></script>
    <script type="module">
      import * as grappl from "./WebBackend.js";

      const showText = "0px 50vw 50vw";
      const noShowText = "0px 100vw 50vw";

      const sexpToSql = (sexp) => {
        if (Array.isArray(sexp)) {
          let sql = "";

          const [func, ...params] = sexp;

          const handlePrev = (ignore = false) => {
            if (!Array.isArray(params[0]))
              return;
            const execParam = params.shift();
            if (!ignore) {
              const prev = sexpToSql(execParam);
              sql += prev;
              sql += '\n';
            }
          };

          if (func.symbol === "SELECT") {
            handlePrev();
            sql += sexpToSql(func) + ' ' + sexpToSql(params[1]);

          } else if (func.symbol === "WHERE") {
            handlePrev();
            sql += sexpToSql(func) + ' ' + params.map(sexpToSql).join(',');

          } else if (func.symbol === "FROM") {
            handlePrev();
            sql += sexpToSql(func) + ' ' + params.map(sexpToSql).join(',');

            // assume it's a binary operator
          } else {
            handlePrev();
            sql += `${sexpToSql(params[0])} ${sexpToSql(func)} ${sexpToSql(params[1])}`;

          }

          return sql;

        } else if (typeof sexp === "object" && "symbol" in sexp) {
          return sexp.symbol;

        } else if (typeof sexp === "string") {
          return `'${sexp}'`

        } else if (typeof sexp === "number") {
          return `${sexp}`

        } else {
          throw Error("unexpected value:", sexp);
        }
      };

      let ide;

      async function main() {
        ide = new Promise((resolve, reject) => {
          document.body.onload = () => {
            const canvas = document.getElementById("dvui-canvas");
            const result = new grappl.Ide(canvas, {
              bindings: {
                jsHost: {
                  functions: {
                    "Confetti": {
                      parameters: [{ name: "particle count", type: grappl.Types.i32 }],
                      results: [],
                      impl(particleCount) {
                        confetti({
                          particleCount,
                          spread: 70,
                          origin: { y: 0.6 },
                        });
                      }
                    },
                    "sql": {
                      parameters: [{ name: "code", type: grappl.Types.code }],
                      results: [],
                      impl(code) {
                        //console.log('s-exp:', code);
                        console.log('QUERY:', sexpToSql(code));
                      }
                    },
                    // dummy nodes
                    "SELECT": {
                      parameters: [{ name: "column", type: grappl.Types.string }],
                      results: [],
                      impl(code) {} // TODO: impl should be optional
                    },
                    "WHERE": {
                      parameters: [{ name: "condition", type: grappl.Types.bool }],
                      results: [],
                      impl(code) {}
                    },
                    "FROM": {
                      parameters: [{ name: "table", type: grappl.Types.string }],
                      results: [],
                      impl(code) {}
                    },
                  }
                }
              }
            });
            resolve(result);
          };

          document.body.onerror = (err) => reject(err);
        });

        document.addEventListener("keydown", (e) => {
          const isCtrlShiftE = e.ctrlKey && e.shiftKey && /[eE]/.test(e.key);
          if (!isCtrlShiftE) return;
          e.preventDefault();
          document.body.style["grid-template-columns"]
            = document.body.style["grid-template-columns"] === showText
            ? noShowText
            : showText;
        });
      }

      void main();
    </script>
  </body>
</html>
