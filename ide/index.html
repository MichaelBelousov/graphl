<!doctype html>
<html lang="en" style="height: 100%;">
  <head>
    <meta charset="utf-8" />

    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Graphl Editor</title>
    <!-- FIXME: remove temp -->
    <script src="https://cdn.jsdelivr.net/npm/@tsparticles/confetti@3.0.3/tsparticles.confetti.bundle.min.js"></script>
  </head>

  <body style="height: 100%; margin: 0; padding: 0;" >
    <style>
        body {
          overflow-x: hidden;
          display: grid;
          grid-template-columns: 0px 100vw 50vw;
          margin: 0;
          padding: 0;
        }
        #dvui-canvas {
          height: 100vh;
          display: block;
          outline: none;
          caret-color: transparent;
        }
        #react-app {
          height: 100vh;
          display: none;
        }
        /* FIXME: was this required in other versions? */
        #confetti {
          pointer-events: none;
        }
    </style>
    <!-- need tabIndex for the canvas to receive keydown/keyup/beforeinput events -->
    <canvas id="dvui-canvas" tabIndex="1"></canvas>
    <div id="react-app"></div>
    <script type="module" src="./demo.tsx"></script>
    <script type="module">
      import * as graphl from "./WebBackend.js";
      import { downloadFile } from "./localFileManip.ts";

      const showText = "0px 50vw 50vw";
      const noShowText = "0px 100vw 50vw";

      /** @type {import("./WebBackend.js").Ide}  */
      let ide;

      async function main() {
        ide = await new Promise((resolve, reject) => {
          document.body.onload = () => {
            const canvas = document.getElementById("dvui-canvas");
            const ideOpts = {
              allowRunning: true,
              userFuncs: {
                "ReturnExtern": {
                  outputs: [{ name: "", type: "extern" }],
                  impl() {
                    return new Uint8Array([1,2,3,4]);
                  },
                },
                "UseExtern": {
                  inputs: [{ name: "", type: "extern" }],
                  impl(arg) {
                    console.log(arg);
                  },
                },
                "Confetti": {
                  inputs: [{ name: "ParticleCount", type: "i32", description: "amount of confetti particles" }],
                  outputs: [],
                  description: "spray confetti everywhere",
                  impl(particleCount) {
                    confetti({
                      particleCount,
                      spread: 70,
                      origin: { y: 0.6 },
                      duration: 2000,
                    });
                  }
                },
                "ProjectCenter": {
                  inputs: [],
                  outputs: [{ name: "center", type: "vec3" }],
                  kind: "pure",
                  tags: ["iTwin"],
                  description: "get the center of the project extents in iTwin coordinates",
                },

                "Category": {
                  inputs: [{ name: "element", type: "u64" }],
                  outputs: [{ name: "", type: "u64" }],
                  tags: ["iTwin"],
                  description: "get the id of the category for a geometric element",
                  kind: "pure",
                },

                "Parent": {
                  inputs: [{ name: "element", type: "u64" }],
                  outputs: [{ name: "", type: "u64" }],
                  tags: ["iTwin"],
                  description: "get the id of the parent of an element",
                  kind: "pure",
                },

                "UserLabel": {
                  inputs: [{ name: "element", type: "u64" }],
                  outputs: [{ name: "", type: "string" }],
                  kind: "pure",
                  tags: ["iTwin"],
                  description: "get the user label of an element",
                },

                "CaselessMatch": {
                  inputs: [
                    { name: "Haystack", type: "string", description: "string to search in" },
                    { name: "Needle", type: "string", description: "string to search for" },
                  ],
                  outputs: [{ name: "Found", type: "bool" }],
                  kind: "pure",
                  description:
                  "return true if a match for the needle is found in the haystack, ignoring case\n" +
                    "so a needle of 'el' would match a haystack of 'HeLLO'",
                },

                "MeshVertexCount": {
                  inputs: [{ name: "MeshId", type: "u64" }],
                  outputs: [{ name: "", type: "i32" }],
                  kind: "pure",
                  description: "get the vertex count for the given geometric element",
                },

                "MetaClusterId": {
                  outputs: [{ name: "", type: "u64" }],
                  kind: "pure",
                  tags: ["clusters"],
                  description: "the one big cluster for merging anything or everything",
                },

                "NoClusterId": {
                  outputs: [{ name: "", type: "u64" }],
                  kind: "pure",
                  tags: ["clusters"],
                  description: "special cluster id which prevents any merging",
                },

                "StringToU64": {
                  inputs: [{ name: "", type: "string" }],
                  outputs: [{ name: "", type: "u64" }],
                  kind: "pure",
                  tags: ["string"],
                  description:
                  "call out to a javascript runtime to execute some JavaScript\n" +
                    "The last unterminated expression is returned",
                },

                "MapByTable": {
                  inputs: [
                    // TODO: add a "description" for floating tooltip
                    {
                      name: "Table",
                      type: "string",
                      // TODO: create a custom "enum" type in the graphl env,
                      // mutated as the tables are added
                      //tags: ["TABLES"],
                    },
                    { name: "Key", type: "string" },
                    { name: "IfNotFound", type: "string" },
                    { name: "MatchPart?", type: "bool" },
                  ],
                  outputs: [{ name: "found", type: "string" }],
                  tags: ["table"],
                  description:
                  "Given the name of a 2-column table and a key,\n" +
                    "search the first column for a matching key\n" +
                    "and return the corresponding value in the second column.\n" +
                    "If nothing matches, return the value provided to 'IfNotFound'\n" +
                    "If 'MatchPart?' is true, choose the first row whose first\n" +
                    "column is found within the key",
                },

                "JavaScriptEval": {
                  inputs: [
                    { name: "Element", type: "u64" },
                    { name: "Code", type: "string" },
                  ],
                  outputs: [{ name: "JsonResult", type: "string" }],
                  tags: ["text"],
                  description:
                  "Call out to a javascript runtime to execute some JavaScript\n" +
                    "The last unterminated expression is returned",
                },
                "BlenderProcessMesh": {
                  inputs: [
                    {
                      name: "geometry",
                      type: "extern",
                      description: "The geometry to process",
                    },
                    {
                      name: "BlenderPath",
                      type: "string",
                      description:
                      'Defaults to "blender" if empty.\n' +
                        'Can be a full path to the exe or a name to look for in PATH',
                    },
                    {
                      name: "ScriptPath",
                      type: "string",
                      description: "Path to a blender script to mutate the blender scene"
                    },
                  ],
                  tags: ["blender"],
                  outputs: [{ name: "", type: "extern" }],
                  description: "Send the geometry through a local blender installation with a script to edit the geometry",
                },
                "VisibleInViewport": {
                  inputs: [{ name: "element", type: "u64" }],
                  outputs: [{ name: "", type: "bool" }],
                  kind: "pure",
                  tags: ["iTwin"],
                  description: "true if the viewport has this element visible at export time",
                },
              },
              menus: [{
                name: "Test",
                onClick: () => console.log("hello!"),
                submenus: [{
                  name: "again",
                  onClick() {
                    const content = ide
                    void downloadFile({
                      fileName: "compiled.wat",
                      content,
                    });
                  }
                }]
              }],
              graphs: {
                "main": {
                  //fixedSignature: true,
                  // inputs: [{
                  //   name: "x",
                  //   type: "string",
                  // }],
                  outputs: [{
                    name: "y",
                    type: "i32",
                  }],
                  nodes: [
                    {
                      id: 1,
                      type: "Confetti",
                      inputs: {
                        0: { node: 0, outPin: 0 },
                        1: { int: 100 },
                      }
                    },
                    {
                      id: 2,
                      type: "return",
                      inputs: {
                        0: { node: 1, outPin: 0 },
                      }
                    },
                  ]
                },

                processInstance: {
                  fixedSignature: true,
                  inputs: [
                    { name: "ElementId", type: "u64", description: "id of the element" },
                    // part or element
                    { name: "GeometrySourceId", type: "u64", description: "id of the source of geometry" },
                    { name: "Origin", type: "vec3", description: "xyz in meters origin" },
                    { name: "Rotation", type: "vec3" },
                    { name: "AnimationBatchId", type: "u64" },
                  ],
                  outputs: [
                    { name: "OutputFile", type: "string", description: "Which datasmith file it goes to" },
                    // TODO: add the ability to put a tooltip on a pin
                    { name: "ClusterId", type: "u64" },
                    { name: "MaterialName", type: "string" },
                    { name: "Ignore", type: "bool" },
                  ],
                  nodes: [
                    {
                      id: 1,
                      type: "NoClusterId",
                    },
                    {
                      id: 2,
                      type: "return",
                      inputs: {
                        0: { node: 0, outPin: 0 },
                        // FIXME: allow editing the graph imperatively so we can set this once the imodel loads
                        1: { string: "imodel" },
                        2: { node: 1, outPin: 0 },
                        3: { string: "/TwinSyncStudio/M_combinedMesh.M_combinedMesh" },
                        4: { bool: false },
                      },
                    }
                  ],
                },
              },
              /*
              preferences: {
                graph: {
                  scale: 0.7,
                  origin: { x: 0, y: 0 },
                },
              },
              */
            };
            graphl.Ide(canvas, ideOpts).then(resolve);
          };

          document.body.onerror = (err) => reject(err);
        });

        document.addEventListener("keydown", (e) => {
          const isCtrlShiftE = e.ctrlKey && e.shiftKey && /[eE]/.test(e.key);
          if (isCtrlShiftE) {
            e.preventDefault();
            document.body.style["grid-template-columns"]
              = document.body.style["grid-template-columns"] === showText
              ? noShowText
              : showText;
          } else if (e.ctrlKey && e.shiftKey && /[xX]/.test(e.key)) {
            e.preventDefault();
            console.log("COMPILED!", ide.exportCompiled());
          }
        });
      }

      void main();
    </script>
  </body>
</html>
